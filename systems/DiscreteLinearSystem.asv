% Class for describing a discrete linear system with dynamics of the form
%   x_{k+1} = Ax_{k} + Bu_{k}
%
%
%   This currently only has the methods to update the state and add noise 
%   to the control input from the control noise distribution 


classdef DiscreteLinearSystem < handle

    properties
        %% System description
        % Right now this is the double integrator system from the paper
        % with delta_t = 0.01
        dt = 0.01;
        A = [eye(2), eye(2)*0.01;
            zeros(2,2), eye(2)];
        x = zeros(4, 1);
        B = [zeros(2, 2);
             eye(2)*0.01];
        u = zeros(2, 1);

        %% System limits
        u_lims = [-5, 5;
                  -5, 5]; % min and max allowable control

        %% Noise definitions
        sigma_control = eye(2)/10; % control noise
        sigma_environment = eye(4)/10; % environmental noise
    end

    methods
        % Constructor
        function obj=DiscreteLinearSystem(varargin)
            % nothing for now
        end

        % Function to set dt. Set this to match the controller frequency
        % of MPPI or iLQR
        function setDt(obj, dt)
            obj.dt = dt;
            obj.A = [eye(2), eye(2)*dt;
                     zeros(2,2), eye(2)];
        end

        % Function to update the state of the system based on current x
        % and u
        function updateState(obj)
            obj.x = obj.A*obj.x + obj.B*obj.u;
        end

        % Set the current control input
        function setControl(obj, u_new)
            obj.u = obj.clipControl(u_new);
        end

        % Function to clip control inputs to control limits
        function u_clipped = clipControl(obj, u)

            % apply control limits to the signal
            u_clipped = u;
            u_clipped(u > obj.u_lims(2)) = obj.u_lims(2);
        end

        % Function to sample control noise num_samples amount of times
        function E = sampleControlNoise(obj, num_samples)
            % add noise from the control noise distribution
            E = transpose(mvnrnd(zeros(size(obj.u)), ...
                                 obj.sigma_control, ...
                                 num_samples));
        end

        function [x_traj, u_traj] = rolloutTraj(obj, u_init, T)
        %% Rollout a single trajectory given initial trajectory of inputs
        %   and the time horizon T
        %
        %   u_init: 2xN matrix where columns are each time step's input.
        %           N needs to equal t/obj.dt so each time step of the
        %           rollout has an input
        %   T: how many seconds into the future to simulate
        %
        %   x_traj: state trajectory over the horizon (t+1 -> N)
        %   u_traj: input trajectory over the horizon (t -> N-1)

            % how many time steps
            N = size(u_init, 2);
            if(N ~= T/obj.dt)
                error("incorrect size of u_init! You need one control input column for each of the N = t/obj.dt time steps\n");
            end

            x_traj = zeros(length(obj.x), N); % states along the trajectory
            u_traj = u_init + obj.sampleControlNoise(N); % input trajectory is the initial control trajectory + sampling of control noise
            u_traj = obj.clipControl(u_traj);
            for i = 1:N
                obj.setControl(u_traj(:, i)); % set system control
                obj.updateState(); % update state to roll forward
                x_traj(:, i) = obj.x; % record the current state
            end
        end
    end
end



